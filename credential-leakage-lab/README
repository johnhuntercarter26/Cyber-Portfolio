# Credential Leakage Detection & Remediation Lab

## Overview
This lab demonstrates a full, real-world credential leakage incident lifecycle in a GitHub repository.  
It covers how credentials are commonly leaked, how such leaks are detected, and—most importantly—how they are **properly remediated**, including removal from Git history.

All credentials used in this lab were **intentionally fake** and created solely for educational purposes.

---

## Objectives
- Simulate a realistic credential leak in a Git repository
- Detect leaked credentials using manual and automated methods
- Contain the incident to prevent further exposure
- Eradicate leaked secrets from Git history
- Verify remediation using automated scanning tools

---

## Tools & Technologies
- **Git / GitHub**
- **Gitleaks** (credential detection)
- **git-filter-repo** (Git history rewriting)
- **PowerShell (Windows)**

---

## Incident Walkthrough

### 1. Credential Leak Simulation
A fake AWS-style access key was intentionally placed in a `.env` file and committed to the repository, simulating a common developer mistake where sensitive configuration files are accidentally tracked by Git and pushed to a public remote.

---

### 2. Detection
The repository was scanned using **Gitleaks**, which identified:
- The presence of credential material
- The affected file path
- The specific commit where the secret was introduced

Manual Git inspection was also used to validate the finding.

---

### 3. Containment
To prevent future leaks:
- A `.gitignore` file was created and committed
- Environment files (e.g., `.env`) were explicitly ignored moving forward

This ensured no new credentials could be accidentally committed.

---

### 4. Eradication
Simply deleting the file was insufficient, as credentials remained in Git history.

Using **git-filter-repo**, the leaked `.env` file was:
- Completely removed from **all historical commits**
- The repository history was rewritten to eliminate all traces of the secret

The cleaned history was then force-pushed to GitHub.

---

### 5. Verification
After remediation:
- Gitleaks was re-run against the repository
- The scan reported **zero leaks**
- The repository history no longer contained credential material

This confirmed successful remediation.

---

## Key Takeaways
- Deleting a secret file does **not** remove it from Git history
- Proper remediation requires **history rewriting**
- Automated tools are essential for both detection and verification
- Credential hygiene must be enforced proactively, not reactively

---

## Skills Demonstrated
- Credential leak detection and response
- Git history analysis and rewriting
- Secure repository configuration
- Incident response lifecycle (detect → contain → eradicate → verify)
- Practical DevSecOps fundamentals

---

## Disclaimer
All credentials used in this lab were fake and generated solely for training purposes.  
No real secrets or production systems were involved.
